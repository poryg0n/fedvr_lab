      module fedvr_conf_struct
      use fedvr
      use fedvr_basis
      implicit none
      contains
      subroutine fedvr_hamilton_conf(scaling,xa,wa,xx,wx,eigval,     &
                         eigenvec,basis)
       integer :: nmax, nout,                                        &
                  mdim2, mdim2s, mfnd, lwork2, liwork2, info,        &
                  vl, vu, il, iu, &
                  i, j, k

       real*8 :: scaling, abstol, start, lap
       real*8, dimension(:) :: xa, wa, xx, wx,  eigval
       real*8, dimension(:,:) :: eigenvec, basis

       real*8, allocatable, dimension(:) :: vec_matup,               &
                                            work2, iwork2, ifail2
  
       real*8, allocatable, dimension(:) :: isuppz
       real*8, allocatable, dimension(:,:) :: ham0, id

       include 'param'
 
 
       nout = 200000
       nmax = (nnbr-1)*lnbr-1
       mdim2 = nmax

       lwork2 = 26*mdim2
       liwork2 = 10*mdim2
       mdim2s = mdim2*(mdim2+1)/2

       if (lwork2.lt.0.or.liwork2.lt.0) then
          write(*,*) "Problem with the integer lwork2 and liwork2"
          write(*,*) lwork2, liwork2
          call abort
       endif


       write(*,*) "Construction of kinetic energy matrix" 
       call cpu_time(start)
       call kinetic_matrix_lobatto(eigenvec,lnbr,nnbr,xa,wa)
!      call basis_1d(basis,lnbr,nnbr,xa,wa)
       call cpu_time(lap)
       write(*,*) "Time required for kinetic energy matrix",         &
                    lap-start 
      
     
       write(*,*) "kinetic matrix built"
       eigenvec=eigenvec/scaling**2
!      basis=basis/scaling**2

       do i=1,lnbr
          do j=1,nnbr-1
             if((i.ne.lnbr).or.(j.ne.(nnbr-1))) then
                k = (nnbr-1)*(i-1)+j
                xx(k) = xa(j+1) + (i-.5d0-.5d0*lnbr)*2
                xx(k) = xx(k)*scaling
                if(j.eq.(nnbr-1)) then
                   wx(k) = dsqrt(wa(nnbr)+wa(1))
                else
                   wx(k) = dsqrt(wa(j+1))
                end if 
                eigenvec(k,k) = eigenvec(k,k) +                       &
!                      potx(xx(k),k,wx(nmax/2+1),nmax,scaling)
                       potx(xx(k),k,wx(k),nmax,scaling)
!               write(909,*) k,potx(xx(k),k,wx(nmax/2+1),nmax,scaling)
!               write(909,*) k,potx(xx(k),k,wx(k),nmax,scaling)
             end if 
          enddo
       enddo



!      write(444,*) "phase 1 : Find the choke points", k 
!      do i=1,lnbr
!         do j=1,nnbr-1
!            if((i.ne.lnbr).or.(j.ne.(nnbr-1))) then
!               k = (nnbr-1)*(i-1)+j
!               write(444,*) k, i, j, xx(k), wx(k)
!               write(445,*) k, i, j, xx(k), basis(8,k)
!            end if
!         enddo
!         write(444,*)
!      enddo



       abstol = 1.0d-30
       if (nout.gt.nmax) nout=nmax


       write(*,*) "diagonalization", nmax 
       call cpu_time(start)

      
!      allocate(vec_matup(mdim2s))
       allocate(work2(lwork2),iwork2(liwork2),ifail2(mdim2))
       allocate(isuppz(2*mdim2))

!      k=0
!      do i=1,nmax
!         do j=1,i
!            k=k+1
!            vec_matup(k)=eigenvec(j,i)
!         enddo
!      enddo
       allocate(ham0(nmax,nmax))
       ham0=eigenvec

!      allocate(id(nmax,nmax))
!      id=0.0d0
!      do i=1,nmax
!         id(i,i)=1.0d0
!      enddo

!      call dspevx('v', 'i', 'u', nmax, vec_matup, vl, vu, 1, nout,   &
!               abstol, mfnd, eigval, eigenvec, nmax, &
!               work2, iwork2, ifail2, info) 

!      call dsygv(1,'v','u',nmax,eigenvec,nmax,id,nmax,eigval,        &
!               work2,lwork2,info)

!      call dsyev('v','u',nmax,eigenvec,nmax,eigval,work2,lwork2,info)

!      call dsyevd('v','u',nmax,eigenvec,nmax,eigval,                 &
!                work2,lwork2,iwork2,liwork2,info)

       call dsyevr('v','a','u',nmax,ham0,nmax,vl,vu,il,iu,            &
          abstol,mfnd,eigval,eigenvec,nmax,                           &
          isuppz,work2,lwork2,iwork2,liwork2,                         &
          info)        

!      deallocate(id)
       deallocate(ham0)
      

       write(*,*) info
       if(info /= 0) then
           write(404,*) "dsyevr info", info
           call flush(404)
           call abort
       end if
       call cpu_time(lap)
       write(*,*) "Time required for diagonalization (dsyevr) ",    &
               lap-start 


       return
       end subroutine
      end 

